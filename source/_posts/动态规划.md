---
title: 动态规划
date: 2020-04-24 14:12:11
tags:
  - 算法思想
  - 动态规划
  - 背包问题
---

动态规划的问题总结如下：

#### 1.斐波那契数列引入动态规划问题

![123](/images/动态规划.png)
使用动态规划思想解决问题的起点是，通过分解目标问题，得到要解决目标问题的子问题。通过对子问题的求解，继而求解其他更加复杂的子问题(包括“最终问题”)。类似递归的逆过程，“递归”是自顶向下的循环求解思想，而“动态规划”是自下而上的求解思想，从子问题向上求解。
下面三个例子都是动态规划的经典问题：

###### 1.求解最长公共子串

题目：给定两个字符串  text1 和  text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的   子序列   是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。
若这两个字符串没有公共子序列，则返回 0。

###### 示例 1

```java
输入：text1 = "abcde", text2 = "ace"
输出：3
解释：最长公共子序列是 "ace"，它的长度为 3。
```

思路为动态规划，使用一个二维数组存储两个字符串相同
位置的字符比较结果。初始化时，该数组的每一个元素被设置为 0。每次在这两个数组的
相同位置发现了匹配，就将数组对应行和列的元素加 1，否则保持为 0。
按照这种方式，一个变量会持续记录下找到了多少个匹配项。当算法执行完毕时，这个变
量会结合一个索引变量来获得最长公共子串。
代码如下：

```javascript
/**
 * @param {string} text1
 * @param {string} text2
 * @return {number}
 */
var longestCommonSubsequence = function (text1, text2) {
  let n = text1.length
  let m = text2.length
  let dp = Array.from(new Array(n + 1), () => new Array(m + 1).fill(0))
  //这里用到了ES6的新Array方法from,实现一个浅拷贝，向数组赋值0，
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= m; j++) {
      if (text1[i - 1] == text2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1
      } else {
        dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j])
      }
    }
  }
  return dp[n][m]
}
```

##### 下面有两道题用到了动态规划，当然也有别的方法，此处只是对动态规划进行应用与演示.

#### 2.leetcode-62-不同路径 I

```java
输入: m = 3, n = 2
输出: 3
解释: 从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下 2. 向右 -> 向下 -> 向右 3. 向下 -> 向右 -> 向右
```

```javascript
/**
 * @param {number} m
 * @param {number} n
 * @return {number}
 */
var uniquePaths = function (m, n) {
  var dp = new Array(m)
  for (let i = 0; i < m; i++) {
    dp[i] = new Array(n)
  }
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (i == 0 || j == 0) {
        dp[i][j] = 1
      } else {
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
      }
    }
  }
  return dp[m - 1][n - 1]
}
```

#### 3.leetcode-63-不同路径 II(障碍物)

```cpp
输入: [   [0,0,0],   [0,1,0],   [0,0,0] ]
输出: 2
解释: 3x3
网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 ->
向右 -> 向下 -> 向下 2. 向下 -> 向下 -> 向右 -> 向右
```

```javascript
/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function (obstacleGrid) {
  var n = obstacleGrid.length
  var m = obstacleGrid[0].length
  var dp = new Array(n)
  for (var i = 0; i < n; i++) {
    dp[i] = new Array(m).fill(0)
  }
  dp[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0
  if (dp[0][0] == 0) {
    return 0
  }
  for (var j = 1; j < m; j++) {
    if (obstacleGrid[0][j] != 1) {
      dp[0][j] = dp[0][j - 1]
    }
  }
  for (var r = 1; r < n; r++) {
    if (obstacleGrid[r][0] != 1) {
      dp[r][0] = dp[r - 1][0]
    }
  }
  for (var i = 1; i < n; i++) {
    for (var r = 1; r < m; r++) {
      if (obstacleGrid[i][r] != 1) {
        dp[i][r] = dp[i - 1][r] + dp[i][r - 1]
      }
    }
  }
  return dp[n - 1][m - 1]
}
```
